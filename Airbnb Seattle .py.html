#!/usr/bin/env python
# coding: utf-8

# # Seattle Airbnb Data Analysis

# As part of the Udacity data science nanodegree course, I have to analyse the Airbnb Seattle dataset for 2016 following the CRISP-DM process.

# # 1. Business Understanding:
# 
# Some of the questions I am anwering over here:
# 
# 1. Which listings are charging the highest price?
# 2. What is the average monthly price charged? 
# 3. How much time does the host take to respond?
# 4. Which are the popular neighbourhoods?
# 5. Which are the most expensive and cheapest neighbourhoods in Seattle?
# 6. What review ratings affect the customer?
# 7. Does avaialbility of certain amenities fetch a higher price?
#     

# # 2. Data Understanding:
# Collecting, wrangling and exploring the data

# In[70]:


###importing the required packages

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython import display
get_ipython().run_line_magic('matplotlib', 'inline')


# In[71]:


###Read the files

df_cal=pd.read_csv('/Users/sanjanasharma/learning/Blog Post/seattle/calendar.csv')
df_listing=pd.read_csv('/Users/sanjanasharma/learning/Blog Post/seattle/listings.csv')


# In[72]:


###looking at the datasets

df_cal.head(5)


# In[73]:


###looking at the datasets

df_listing.head(5)


# ## Exploring the Calendar dataset
# 
# 1. Identify # of rows and columns
# 2. Missing values
# 3. Describe the variables in the dataset and look at the datatypes
# 4. Data Wrangling: <ul>
#     <li>Clean/convert Price from String to Float </li>
#     <li>Extract Month from the dates</li>
#     </ul>

# In[74]:


###Exploring the calendar dataset

###Number of rows and columns
print('Number of rows and columns:',df_cal.shape)
print()

###Number of missing values for price
print('Percentage of Missing values:',(df_cal.isnull().sum()/len(df_cal))*100)
print()

###Describe
print(df_cal.describe(include='all'))


# In[7]:


###Datatypes for calendar dataset

df_cal.dtypes


# In[75]:


#######Cleaning up Price variable
#Can't convert directly to int since it has string values
#first convert to str and remove the dollar sign and the comma, then convert to float

df_cal["price"]=df_cal["price"].str.replace(',','')
df_cal["price"]=df_cal["price"].str.replace('$','')

df_cal["price"]=df_cal["price"].astype(float)


# In[76]:


### remove the missing price values, so convert to 0
###since that would still mean price is unavaialble or not displayed and wont affect the data set
df_cal["price"].fillna(0, inplace=True)
df_cal["price"].head()


# In[77]:


###Looking at the Date range available in the dataset
print(" Date range for the listings: ",df_cal['date'].min(),"to ", df_cal['date'].max())


# In[78]:


#####Extracting Month from the dates

##converting date to datetime to extract  month  later
df_cal['date_column'] = pd.to_datetime(df_cal['date'])
##creating a Month column from the date column
df_cal['Month']=df_cal['date_column'].dt.month
df_cal['Month'].head()


# ### a. Exploring price 

# In[81]:


###total sum of all prices charged
total_earned=np.sum(df_cal["price"])
print("Sum of all prices charged through the year: $",total_earned)


# In[14]:


####sum of prices charged per month
monthly_bookings=df_cal.groupby('Month')['price'].count()
print(monthly_bookings)


# In[16]:


###average price charged per listing for the year
avg_price=total_earned/df_cal['listing_id'].nunique()  
print("Average earning per listing: $",round(avg_price,0))


# In[18]:


###Average price charged per listing 
print("Average price charged per listing: $", round(df_cal['price'].mean(),0))


# In[87]:


## Average price charged per listing
mean_price_listing=df_cal.groupby('listing_id')['price'].mean()
mean_price_listing


# In[102]:


##Average price charged for the top 10 listings
print("Avg price for Top 10 most expensive listings: $",round(mean_price_listing.nlargest(10).mean(),0))


# In[30]:


###Listing avaialble through most of the year
listing_avlb=(df_cal.groupby('available')['listing_id'].count()/df_cal.shape[0])*100
print("Listings % avaialbility through the year:", round(listing_avlb,0))


# In[104]:


###Average Price charged per month
df_cal.groupby('Month')['price'].mean()


# In[56]:


month_price=df_cal.groupby('Month')['price'].mean().plot()
plt.ylabel('Average Price')


# # Exploring the Listing dataset
# 
# 1. Identify # of rows and columns
# 2. Missing values
# 3. Describe the variables in the dataset and look at the datatypes
# 4. Data Wrangling: Clean/convert Price from String to Float
# 5. Identify all the categorical and quantitative variables
# 6. Observing the average price charged per neighbourhood
# 7. Ratings and amenities correlation

# In[33]:


###For the listings dataset

##Number of rows and columns
print('Number of rows and columns:',df_listing.shape)
print()

###Number of missing values
print('Percentage of Missing values:',(df_listing.isnull().sum()/len(df_listing))*100)
print()

##Describe
print(df_listing.describe(include='all'))


# In[82]:


###Cleaning the price variable and converting to float
df_listing["price"]=df_listing["price"].str.replace('$','')
df_listing["price"]=df_listing["price"].str.replace(',','')

df_listing["price"]=df_listing["price"].astype(float)


# In[34]:


### identify all the categorical variables
df_listing.select_dtypes(include="object").columns


# In[85]:


### identify all the quantitative variables
df_listing.select_dtypes(include=("float64","int64")).columns


# In[108]:


##Host response time
df_listing['host_response_time'].value_counts()


# In[119]:


###Average price per neighbourhood
neighbourhood_price=df_listing.groupby('neighbourhood_cleansed')['price'].mean().plot()
plt.xlabel('Neighbourhoods')


# In[115]:


###create a dataframe with ratings scores
df_reviews=df_listing[['review_scores_rating',
       'review_scores_accuracy', 'review_scores_cleanliness',
       'review_scores_checkin', 'review_scores_communication',
       'review_scores_location', 'review_scores_value','price']]

###Correlation matrix
corr_ratings=df_reviews.corr()
corr_ratings


# In[117]:


###create a dataframe with amenities listed
df_amenities=df_listing[['bathrooms', 'bedrooms', 'beds','guests_included',
       'minimum_nights', 'maximum_nights','price']]

###Correlation matrix
corr_amen=df_amenities.corr()
corr_amen


# # Analyzing the data

# ### 1. Which listings are charging the highest price?

# In[97]:


###Highest price charged listings
mean_price_listing=df_cal.groupby('listing_id')['price'].mean()
mean_price_listing.nlargest(10).plot(kind="barh");
plt.xlabel('Price charged')
plt.axvline(mean_price_listing.nlargest(10).mean(),color='r',linestyle='--')##average price for top 10= $814
plt.title("Top 10 listings charging the highest price")


# ### 2. What is the average price charged per month? 

# In[103]:


###The months with highest price
mth_price_listing=df_cal.groupby('Month')['price'].mean()
mth_price_listing.plot(kind="bar");
plt.xlabel('Month')
plt.ylabel('Average Price')
plt.title("Avg Price charged per month")
plt.axhline(mth_price_listing.mean(),color='g',linestyle='--')##average price for 2016= $92
plt.legend()


# ### Observation:<br>
# June and december are the peak price months. These months are the summer and christmas vacation times of the year and the data reflects that during vacation time, the prices tend to peak.
# While in Q1 2016, price charged was lower than the average for the whole year. 

# ### 3. How much time does the host take to respond?

# In[58]:


###Host response time

resp_time=df_listing['host_response_time'].value_counts()
((resp_time/df_listing.shape[0])*100).plot(kind="bar");
plt.xlabel('Host response time')
plt.ylabel('% Host population')
plt.title("Response Time")


# ### Observation:
# c45% of the hosts respond within an hour

# ### 4. Which are the popular neighbourhoods?

# In[62]:


###identifying the top 15 popular neighbour hoods
loca=df_listing['neighbourhood_cleansed'].value_counts()

((loca[0:15]/df_listing.shape[0])*100).plot(kind="bar");
plt.ylabel('% Listing population')
plt.xlabel('Neighbourhoods')
plt.title("Top 15 popular neighbourhoods in Seattle");


# ### Observation:
# 
# 20% of the properties are located in Broadway, Belltown and Wallingford. 

# ### 5. Which are the most expensive and cheapest neighbourhoods in Seattle?
# __1. Most Expensive neighbourhoods in Seattle__

# In[68]:


###10 most expensive neighbourhoods
top10_n = df_listing.groupby(['neighbourhood_cleansed'])[['price']].mean().sort_values("price",ascending=False).head(10)
top10_n.plot(kind="bar")
plt.ylabel('% Listing population')
plt.xlabel('Neighbourhoods')

plt.title("Top 10 most expensive neighbourhoods in Seattle");


# __2. Cheapest neighbourhoods in Seattle__

# In[69]:


###10 least expensive neighbourhoods
bottom10_n = df_listing.groupby(['neighbourhood_cleansed'])[['price']].mean().sort_values("price",ascending=True).head(10)
bottom10_n.plot(kind="bar")
plt.ylabel('% Listing population')
plt.xlabel('Neighbourhoods')
plt.title(" 10 Lowest priced neighbourhoods in Seattle");


# ### 6. What review ratings affect the customer or price?

# In[116]:


### Correlation
corr_ratings=df_reviews.corr()
fig=plt.figure()
ax=fig.add_subplot(111)
cax = ax.matshow(corr,cmap='coolwarm', vmin=-1, vmax=1)
fig.colorbar(cax)
ticks = np.arange(0,len(df_reviews.columns),1)
ax.set_xticks(ticks)
plt.xticks(rotation=90)
ax.set_yticks(ticks)
ax.set_xticklabels(df_reviews.columns)
ax.set_yticklabels(df_reviews.columns)
plt.show()


# ### Observation:
# __Ratings__: Cleanliness has the highest correlation with over all ratings, thus cleanliness is rather important for a good rating. Along with that, good interaction (or communication) with the customer is highly correlated with the check in rating. 
# 
# __Ratings and price__: Ratings have little impact on the price charged by the host. Review ratings and location does have a low positive correlation with price (approx. 5% and 7%).

# ### 7. Does availability of certain amenities fetch a higher price?

# In[120]:


###check correlation
corr_amen=df_amenities.corr()
fig=plt.figure()
ax=fig.add_subplot(111)
cax = ax.matshow(corr,cmap='coolwarm', vmin=-1, vmax=1)
fig.colorbar(cax)
ticks = np.arange(0,len(df_amenities.columns),1)
ax.set_xticks(ticks)
plt.xticks(rotation=90)
ax.set_yticks(ticks)
ax.set_xticklabels(df_amenities.columns)
ax.set_yticklabels(df_amenities.columns)
plt.show()


# ### Observation:
# 
# __Amenities and Price__: Beds, bedrooms and bathrooms offered by the host tend to affect price positively. 
# Minimum and maximum nights offered do not affect price as such.
